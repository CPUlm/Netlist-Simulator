#ifndef NETLIST_INSTRUCTION_HPP
#define NETLIST_INSTRUCTION_HPP

#include <cstdint>
#include <cstring>
#include <memory>
#include <type_traits>
#include <vector>

/// The different implemented opcodes (operator code) for the Netlist bytecode.
enum class OpCode : std::uint32_t {
  /// A no-op instruction that takes no data.
  NOP,
  /// The virtual breakpoint instruction, used to implement the debugger.
  BREAK,
  /// An instruction that loads a constant into a register.
  CONST,
  /// The `output = NOT input` instruction.
  NOT,
  /// The `output = AND lhs_input rhs_input` instruction.
  AND,
  /// The `output = OR lhs_input rhs_input` instruction.
  OR,
  /// The `output = NAND lhs_input rhs_input` instruction.
  NAND,
  /// The `output = NOR lhs_input rhs_input` instruction.
  NOR,
  /// The `output = XOR lhs_input rhs_input` instruction.
  XOR,
  /// The `output = REG input` instruction.
  REG,
  /// The `output = SLICE first end input` instruction.
  SLICE,
  /// The `output = SLICE i input` instruction.
  SELECT
};

struct RegInfo {
  uint8_t bit_width = 1;
};

struct ByteCode {
  std::vector<RegInfo> registers;
  std::vector<std::uint32_t> words;
};

using Constant32 = std::uint32_t;
using Constant64 = std::uint64_t;
using RegIndex = std::uint32_t;

using RegValue = Constant64;

#define DECLARE_INSTRUCTION(name)                                                                                      \
  static_assert(std::is_trivially_copyable_v<name>, #name " must be trivially copyable");                              \
  inline bool operator==(const name &l, const name &r) {                                                               \
    return std::memcmp(&l, &r, sizeof(name)) == 0;                                                                     \
  }

/// The data for the `CONST` instruction that loads a constant
/// into a given register.
struct ConstInstruction {
  RegIndex output;
  Constant64 value;
};

DECLARE_INSTRUCTION(ConstInstruction);

/// The data for the `output = NOT input` instruction.
struct NotInstruction {
  RegIndex output;
  RegIndex input;
};

DECLARE_INSTRUCTION(NotInstruction);

/// The data for a binary instruction such as `output = AND input_lhs input_rhs`.
struct BinaryInstruction {
  RegIndex output;
  RegIndex input_lhs;
  RegIndex input_rhs;
};

DECLARE_INSTRUCTION(BinaryInstruction);

/// Implements the `RAM addr_size word_size read_addr write_enable write_addr write_data`.
struct RamInstruction {
  Constant32 addr_size;
  Constant32 word_size;
  RegIndex read_addr;
  RegIndex write_enable;
  RegIndex write_addr;
  RegIndex write_data;
};

DECLARE_INSTRUCTION(RamInstruction);

/// The data for the `output = REG input` instruction.
struct RegInstruction {
  RegIndex output;
  RegIndex input;
};

DECLARE_INSTRUCTION(RegInstruction);

/// The data for the `output = SLICE first end input`.
struct SliceInstruction {
  RegIndex output;
  Constant32 first; // inclusive, 0-based index
  Constant32 end;   // inclusive, 0-based index
  RegIndex input;
};

DECLARE_INSTRUCTION(SliceInstruction);

/// The data for the `output = SELECT i input`.
struct SelectInstruction {
  RegIndex output;
  Constant32 i; // 0-based index
  RegIndex input;
};

DECLARE_INSTRUCTION(SelectInstruction);

namespace helper {
template <typename T> [[nodiscard]] constexpr size_t size_in_bits() {
  return sizeof(T) * CHAR_BIT;
}
} // namespace helper

/// An utility class to generate bytecode for the Netlist simulator.
///
/// You generate the different instructions using the write_*() functions then
/// call the finish() command to return the final generated bytecode. Each used
/// register must be registered before by calling register_reg(). Additionally,
/// each instruction must be valid and each register reference should be correct.
/// Example, the output register of a SELECT instruction must have a bit-width of 1.
///
/// See the documentation for OpCode and *Instruction structures to understand
/// what each instruction does and what data they take.
class ByteCodeWriter {
public:
  RegIndex register_reg(uint8_t bit_width = 1);

  void write_nop();
  void write_const(const ConstInstruction &data);
  void write_not(const NotInstruction &data);
  void write_binary_inst(OpCode binary_opcode, const BinaryInstruction &data);
  void write_and(const BinaryInstruction &data);
  void write_or(const BinaryInstruction &data);
  void write_nand(const BinaryInstruction &data);
  void write_nor(const BinaryInstruction &data);
  void write_xor(const BinaryInstruction &data);
  void write_reg(const RegInstruction &data);
  void write_slice(const SliceInstruction &data);
  void write_select(const SelectInstruction &data);

  [[nodiscard]] ByteCode finish();

private:
  template <class InstructionData> void write_instruction(OpCode opcode, const InstructionData &data) {
    static_assert(std::is_trivially_copyable_v<InstructionData>, "InstructionData must be trivially copyable");

    m_bytecode.push_back(static_cast<uint32_t>(opcode));

    constexpr size_t data_size_in_words = sizeof(InstructionData) / sizeof(uint32_t);
    m_bytecode.resize(m_bytecode.size() + data_size_in_words);
    std::memcpy(m_bytecode.data() + (m_bytecode.size() - data_size_in_words), &data, sizeof(InstructionData));
  }

  [[nodiscard]] bool is_valid_register(RegIndex reg) const { return reg < m_registers.size(); }

private:
  std::vector<RegInfo> m_registers;
  std::vector<uint32_t> m_bytecode;
};

template <typename Derived> class ByteCodeReader {
public:
  explicit ByteCodeReader(const ByteCode &bytecode)
      : m_begin(bytecode.words.data()), m_ptr(m_begin), m_end(bytecode.words.data() + bytecode.words.size()) {}

  /// Returns true the reader has reached the end of the bytecode.
  [[nodiscard]] bool at_end() const { return m_ptr >= m_end; }
  /// Returns the word position inside the bytecode.
  [[nodiscard]] size_t get_position() const { return std::distance(m_begin, m_ptr); }
  /// Reads all instruction until end of bytecode is reached.
  void read_all() {
    while (!at_end())
      read_one();
  }

  /// Reads one instruction.
  void read_one() {
    const auto opcode = consume_opcode();
    switch (opcode) {
    case OpCode::NOP:
      return static_cast<Derived *>(this)->handle_nop();
    case OpCode::BREAK:
      return static_cast<Derived *>(this)->handle_break();
    case OpCode::CONST:
      return static_cast<Derived *>(this)->handle_const(consume_data<ConstInstruction>());
    case OpCode::NOT:
      return static_cast<Derived *>(this)->handle_not(consume_data<NotInstruction>());
    case OpCode::AND:
      return static_cast<Derived *>(this)->handle_and(consume_data<BinaryInstruction>());
    case OpCode::OR:
      return static_cast<Derived *>(this)->handle_or(consume_data<BinaryInstruction>());
    case OpCode::NAND:
      return static_cast<Derived *>(this)->handle_nand(consume_data<BinaryInstruction>());
    case OpCode::NOR:
      return static_cast<Derived *>(this)->handle_nor(consume_data<BinaryInstruction>());
    case OpCode::XOR:
      return static_cast<Derived *>(this)->handle_xor(consume_data<BinaryInstruction>());
    case OpCode::REG:
      return static_cast<Derived *>(this)->handle_reg(consume_data<RegInstruction>());
    case OpCode::SLICE:
      return static_cast<Derived *>(this)->handle_slice(consume_data<SliceInstruction>());
    case OpCode::SELECT:
      return static_cast<Derived *>(this)->handle_select(consume_data<SelectInstruction>());
    }
  }

  void handle_nop() {}
  void handle_break() {}
  void handle_const(const ConstInstruction &) {}
  void handle_not(const NotInstruction &) {}
  void handle_and(const BinaryInstruction &) {}
  void handle_or(const BinaryInstruction &) {}
  void handle_nand(const BinaryInstruction &) {}
  void handle_nor(const BinaryInstruction &) {}
  void handle_xor(const BinaryInstruction &) {}
  void handle_reg(const RegInstruction &) {}
  void handle_slice(const SliceInstruction &) {}
  void handle_select(const SelectInstruction &) {}

private:
  [[nodiscard]] OpCode consume_opcode() {
    const auto opcode = *reinterpret_cast<const OpCode *>(m_ptr);
    m_ptr += 1;
    return opcode;
  }

  template <class T> [[nodiscard]] const T &consume_data() {
    const auto &data = *reinterpret_cast<const T *>(m_ptr);
    m_ptr += sizeof(T) / sizeof(uint32_t);
    return data;
  }

private:
  const uint32_t *m_begin = nullptr;
  const uint32_t *m_ptr = nullptr;
  const uint32_t *m_end = nullptr;
};

/// The bytecode disassembler. This class takes a bytecode and then outputs
/// a textual representation to the given stdio stream.
///
/// The output is intended to contain the maximum information and it is mean
/// for debugging purposes.
///
/// Example of output:
/// ```
/// AND r0, r1, r2
/// NOT r0, r0
/// SELECT r3, r0, 5
/// ```
class Disassembler {
public:
  static void disassemble(const ByteCode &bytecode, std::FILE *stream = stdout);

private:
  struct Detail : public ByteCodeReader<Detail> {
    using ByteCodeReader::ByteCodeReader;

    std::FILE *stream = nullptr;

    void handle_nop() const;
    void handle_break() const;
    void handle_const(const ConstInstruction &inst) const;
    void handle_not(const NotInstruction &inst) const;
    void handle_binary_inst(const char *name, const BinaryInstruction &inst) const;
    void handle_and(const BinaryInstruction &inst) const;
    void handle_or(const BinaryInstruction &inst) const;
    void handle_nand(const BinaryInstruction &inst) const;
    void handle_nor(const BinaryInstruction &inst) const;
    void handle_xor(const BinaryInstruction &inst) const;
    void handle_reg(const RegInstruction &inst) const;
    void handle_slice(const SliceInstruction &inst) const;
    void handle_select(const SelectInstruction &inst) const;
  };
};

#endif
