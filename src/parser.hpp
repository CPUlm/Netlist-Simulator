#ifndef NETLIST_PARSER_HPP
#define NETLIST_PARSER_HPP

#include "lexer.hpp"
#include "program.hpp"
#include "report.hpp"

#include <functional>
#include <unordered_map>
#include <unordered_set>

/// \addtogroup parser The lexical and syntax analysis
/// @{

/// \brief The syntax analyser for the Netlist language.
///
/// The parser takes a Lexer as input and returns a parsed Netlist Program.
/// If any error is found, a null program is returned. Furthermore, the parser
/// stops at the first error encountered. All errors and warnings are emitted
/// using the report API via the given ReportManager instance.
///
/// If you are curious, the parser is implemented internally using the recursive
/// descent algorithm.
class Parser {
public:
  explicit Parser(ReportManager &report_manager, Lexer &lexer);

  [[nodiscard]] std::shared_ptr<Program> parse_program();

private:
  /// Consumes the current token and gets the next one.
  void consume();

  static constexpr size_t MAX_VARIABLE_SIZE = 64;
  std::optional<bus_size_t> parse_size_specifier();
  bool parse_variables_common(bool allow_size_specifier,
                              const std::function<bool(SourceLocation, std::string_view, size_t)> &handler);
  bool parse_inputs();
  bool parse_outputs();
  bool parse_variables();

  [[nodiscard]] std::pair<reg_value_t, bus_size_t> parse_constant();
  [[nodiscard]] bus_size_t parse_bus_size(bool as_index = false);
  void check_invalid_digits(Token& token, unsigned radix);

  bool parse_equations();
  bool parse_equation();
  bool parse_expression(reg_t output_reg);
  std::optional<reg_t> parse_argument();
  bool parse_const_expression(reg_t output_reg);
  bool parse_load_expression(reg_t output_reg);
  bool parse_not_expression(reg_t output_reg);
  bool parse_reg_expression(reg_t output_reg);
  bool parse_binary_expression(reg_t output_reg);
  bool parse_mux_expression(reg_t output_reg);
  bool parse_concat_expression(reg_t output_reg);
  bool parse_select_expression(reg_t output_reg);
  bool parse_slice_expression(reg_t output_reg);
  bool parse_rom_expression(reg_t output_reg);
  bool parse_ram_expression(reg_t output_reg);

  void emit_unexpected_token_error(const Token &token, std::string_view expected_token_name);

private:
  ReportManager &m_report_manager;
  Lexer &m_lexer;
  Token m_token;
  ProgramBuilder m_program_builder;

  struct VariableInfo {
    /// The register allocated to this variable in the generated bytecode.
    reg_t reg;
    /// The source location where the variable is defined.
    SourceLocation location = INVALID_LOCATION;
    /// Does this variable represents an input? If true, then the variable
    /// was defined inside a `INPUT` declaration.
    bool is_input = false;
    /// Does this variable represents an output? If true, then the variable
    /// was defined inside a `OUTPUT` declaration.
    bool is_output = false;
  };

  std::unordered_map<std::string_view, VariableInfo> m_variables;
};

/// @}

#endif // NETLIST_PARSER_HPP
