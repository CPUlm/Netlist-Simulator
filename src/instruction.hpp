#ifndef NETLIST_INSTRUCTION_HPP
#define NETLIST_INSTRUCTION_HPP

#include <cstdint>
#include <cstring>
#include <memory>
#include <type_traits>
#include <vector>

/// The different implemented opcodes (operator code) for the Netlist bytecode.
enum class OpCode : std::uint32_t {
  /// A no-op instruction that takes no data.
  NOP,
  /// The virtual breakpoint instruction, used to implement the debugger.
  BREAK,
  /// An instruction that loads a constant into a register.
  CONST,
  /// The `output = NOT input` instruction.
  NOT,
  /// The `output = AND lhs_input rhs_input` instruction.
  AND,
  /// The `output = OR lhs_input rhs_input` instruction.
  OR,
  /// The `output = NAND lhs_input rhs_input` instruction.
  NAND,
  /// The `output = NOR lhs_input rhs_input` instruction.
  NOR,
  /// The `output = XOR lhs_input rhs_input` instruction.
  XOR,
  /// The `output = REG input` instruction.
  REG,
  /// The `output = SLICE first end input` instruction.
  SLICE,
  /// The `output = SLICE i input` instruction.
  SELECT
};

struct RegInfo {
  uint8_t bit_width = 1;
};

struct ByteCode {
  std::vector<RegInfo> registers;
  std::vector<std::uint32_t> words;
};

using Constant32 = std::uint32_t;
using Constant64 = std::uint64_t;
using RegIndex = std::uint32_t;

using RegValue = Constant64;

#define DECLARE_INSTRUCTION(name)                                                                                      \
  static_assert(std::is_trivially_copyable_v<name>, #name " must be trivially copyable");                              \
  inline bool operator==(const name &l, const name &r) {                                                               \
    return std::memcmp(&l, &r, sizeof(name)) == 0;                                                                     \
  }

/// The data for the `CONST` instruction that loads a constant
/// into a given register.
struct ConstInstruction {
  RegIndex output;
  Constant64 value;
};

DECLARE_INSTRUCTION(ConstInstruction);

/// The data for the `output = NOT input` instruction.
struct NotInstruction {
  RegIndex output;
  RegIndex input;
};

DECLARE_INSTRUCTION(NotInstruction);

/// The data for a binary instruction such as `output = AND input_lhs input_rhs`.
struct BinaryInstruction {
  RegIndex output;
  RegIndex input_lhs;
  RegIndex input_rhs;
};

DECLARE_INSTRUCTION(BinaryInstruction);

/// Implements the `RAM addr_size word_size read_addr write_enable write_addr write_data`.
struct RamInstruction {
  Constant32 addr_size;
  Constant32 word_size;
  RegIndex read_addr;
  RegIndex write_enable;
  RegIndex write_addr;
  RegIndex write_data;
};

DECLARE_INSTRUCTION(RamInstruction);

/// The data for the `output = REG input` instruction.
struct RegInstruction {
  RegIndex output;
  RegIndex input;
};

DECLARE_INSTRUCTION(RegInstruction);

/// The data for the `output = SLICE first end input`.
struct SliceInstruction {
  RegIndex output;
  Constant32 first; // inclusive, 0-based index
  Constant32 end;   // inclusive, 0-based index
  RegIndex input;
};

DECLARE_INSTRUCTION(SliceInstruction);

/// The data for the `output = SELECT i input`.
struct SelectInstruction {
  RegIndex output;
  Constant32 i; // 0-based index
  RegIndex input;
};

DECLARE_INSTRUCTION(SelectInstruction);

namespace helper {
template <typename T> [[nodiscard]] constexpr size_t size_in_bits() {
  return sizeof(T) * CHAR_BIT;
}
} // namespace helper

/// An utility class to generate bytecode for the Netlist simulator.
///
/// You generate the different instructions using the write_*() functions then
/// call the finish() command to return the final generated bytecode. Each used
/// register must be registered before by calling register_reg(). Additionally,
/// each instruction must be valid and each register reference should be correct.
/// Example, the output register of a SELECT instruction must have a bit-width of 1.
///
/// See the documentation for OpCode and *Instruction structures to understand
/// what each instruction does and what data they take.
class ByteCodeWriter {
public:
  RegIndex register_reg(uint8_t bit_width = 1);

  void write_nop();
  void write_const(const ConstInstruction &data);
  void write_not(const NotInstruction &data);
  void write_and(const BinaryInstruction &data);
  void write_or(const BinaryInstruction &data);
  void write_nand(const BinaryInstruction &data);
  void write_nor(const BinaryInstruction &data);
  void write_xor(const BinaryInstruction &data);
  void write_reg(const RegInstruction &data);
  void write_slice(const SliceInstruction &data);
  void write_select(const SelectInstruction &data);

  [[nodiscard]] ByteCode finish();

private:
  template <class InstructionData> void write_instruction(OpCode opcode, const InstructionData &data) {
    static_assert(std::is_trivially_copyable_v<InstructionData>, "InstructionData must be trivially copyable");

    m_bytecode.push_back(static_cast<uint32_t>(opcode));

    constexpr size_t data_size_in_words = sizeof(InstructionData) / sizeof(uint32_t);
    m_bytecode.resize(m_bytecode.size() + data_size_in_words);
    std::memcpy(m_bytecode.data() + (m_bytecode.size() - data_size_in_words), &data, sizeof(InstructionData));
  }

  [[nodiscard]] bool is_valid_register(RegIndex reg) const {
    return reg < m_registers.size();
  }

private:
  std::vector<RegInfo> m_registers;
  std::vector<uint32_t> m_bytecode;
};

template <typename Derived> class ByteCodeReader {
public:
  explicit ByteCodeReader(const ByteCode &bytecode)
      : m_begin(bytecode.words.data()), m_ptr(m_begin), m_end(bytecode.words.data() + bytecode.words.size()) {}

  /// Returns true the reader has reached the end of the bytecode.
  [[nodiscard]] bool at_end() const { return m_ptr >= m_end; }
  /// Returns the word position inside the bytecode.
  [[nodiscard]] size_t get_position() const { return std::distance(m_begin, m_ptr); }
  /// Reads all instruction until end of bytecode is reached.
  void read_all() {
    while (!at_end())
      read_one();
  }

  /// Reads one instruction.
  void read_one() {
    const auto opcode = consume_opcode();
    switch (opcode) {
    case OpCode::NOP:
      return static_cast<Derived *>(this)->handle_nop();
    case OpCode::BREAK:
      return static_cast<Derived *>(this)->handle_break();
    case OpCode::CONST:
      return static_cast<Derived *>(this)->handle_const(consume_data<ConstInstruction>());
    case OpCode::NOT:
      return static_cast<Derived *>(this)->handle_not(consume_data<NotInstruction>());
    case OpCode::AND:
      return static_cast<Derived *>(this)->handle_and(consume_data<BinaryInstruction>());
    case OpCode::OR:
      return static_cast<Derived *>(this)->handle_or(consume_data<BinaryInstruction>());
    case OpCode::NAND:
      return static_cast<Derived *>(this)->handle_nand(consume_data<BinaryInstruction>());
    case OpCode::NOR:
      return static_cast<Derived *>(this)->handle_nor(consume_data<BinaryInstruction>());
    case OpCode::XOR:
      return static_cast<Derived *>(this)->handle_xor(consume_data<BinaryInstruction>());
    case OpCode::REG:
      return static_cast<Derived *>(this)->handle_reg(consume_data<RegInstruction>());
    case OpCode::SLICE:
      return static_cast<Derived *>(this)->handle_slice(consume_data<SliceInstruction>());
    case OpCode::SELECT:
      return static_cast<Derived *>(this)->handle_select(consume_data<SelectInstruction>());
    }
  }

  void handle_nop() {}
  void handle_break() {}
  void handle_const(const ConstInstruction &) {}
  void handle_not(const NotInstruction &) {}
  void handle_and(const BinaryInstruction &) {}
  void handle_or(const BinaryInstruction &) {}
  void handle_nand(const BinaryInstruction &) {}
  void handle_nor(const BinaryInstruction &) {}
  void handle_xor(const BinaryInstruction &) {}
  void handle_reg(const RegInstruction &) {}
  void handle_slice(const SliceInstruction &) {}
  void handle_select(const SelectInstruction &) {}

private:
  [[nodiscard]] OpCode consume_opcode() {
    const auto opcode = *reinterpret_cast<const OpCode *>(m_ptr);
    m_ptr += 1;
    return opcode;
  }

  template <class T> [[nodiscard]] const T &consume_data() {
    const auto &data = *reinterpret_cast<const T *>(m_ptr);
    m_ptr += sizeof(T) / sizeof(uint32_t);
    return data;
  }

private:
  const uint32_t *m_begin = nullptr;
  const uint32_t *m_ptr = nullptr;
  const uint32_t *m_end = nullptr;
};

/// The bytecode disassembler. This class takes a bytecode and then outputs
/// a textual representation to the given stdio stream.
///
/// The output is intended to contain the maximum information and it is mean
/// for debugging purposes.
///
/// Example of output:
/// ```
/// AND r0, r1, r2
/// NOT r0, r0
/// SELECT r3, r0, 5
/// ```
class Disassembler {
public:
  static void disassemble(const ByteCode &bytecode, std::FILE *stream = stdout);

private:
  struct Detail : public ByteCodeReader<Detail> {
    using ByteCodeReader::ByteCodeReader;

    std::FILE *stream = nullptr;

    void handle_nop() const;
    void handle_break() const;
    void handle_const(const ConstInstruction &inst) const;
    void handle_not(const NotInstruction &inst) const;
    void handle_binary_inst(const char *name, const BinaryInstruction &inst) const;
    void handle_and(const BinaryInstruction &inst) const;
    void handle_or(const BinaryInstruction &inst) const;
    void handle_nand(const BinaryInstruction &inst) const;
    void handle_nor(const BinaryInstruction &inst) const;
    void handle_xor(const BinaryInstruction &inst) const;
    void handle_reg(const RegInstruction &inst) const;
    void handle_slice(const SliceInstruction &inst) const;
    void handle_select(const SelectInstruction &inst) const;
  };
};

/// Represents the data of a breakpoint inside a Netlist bytecode. This is a critical
/// data piece used to implement and interact with the Netlist debugger.
struct BreakPoint {
  /// The offset into the bytecode where this breakpoint is located. It is an index
  /// into the bytecode's words array.
  std::size_t offset = 0;
  /// Breakpoint are implemented using a special instruction. The debugger patch the
  /// bytecode by replacing an instruction by a breakpoint instruction. However, when
  /// it is time to resume the execution, the previous bytecode must be recovered.
  /// Because a breakpoint instruction is always encoded as a single word, we only need
  /// store a single word to fully recover the previous bytecode (before the breakpoint
  /// being added).
  ///
  /// As a matter of fact, breakpoints in the Netlist simulator are implemented similarly
  /// as real breakpoints in x86 or ARM code.
  std::uint32_t saved_word = 0;
  /// Is the breakpoint oneshot? If true, then the breakpoint is automatically removed
  /// once reached.
  bool oneshot = false;
  /// Is the breakpoint currently active? That is the underlying bytecode patched to
  /// detect this breakpoint or not.
  /// Not active breakpoints are ignored by the simulator.
  bool is_active = false;

  void activate(ByteCode &bytecode);
  void deactivate(ByteCode &bytecode);
};

/// The Netlist simulator / virtual machine.
///
/// Actually, the simulator is implemented as a very small virtual machine that
/// takes a list of instructions (the Netlist bytecode) and interprets each instruction
/// step by step. The actual implementation of each instruction is done inside the
/// private execute_*() functions.
///
/// Because the debugger is really simple, it is implemented inside the simulator itself.
/// Therefore, the debugger API is part of the Simulator API. See the add_breakpoint(),
/// print_registers(), print_ram(), and like, functions. Likewise, the execute() and step()
/// functions are fully aware of breakpoints.
class Simulator {
public:
  Simulator(const ByteCode &bytecode) : m_d(bytecode) {}

  /// Returns the current bytecode being simulated.
  [[nodiscard]] ByteCode &get_bytecode() { return m_d.bytecode; }
  [[nodiscard]] const ByteCode &get_bytecode() const { return m_d.bytecode; }

  // ------------------------------------------------------
  // The Debugger API
  // ------------------------------------------------------

  // ------------------------
  // The breakpoints API

  /// Returns true if the simulator is stopped at a breakpoint in the bytecode.
  ///
  /// If it is the case, you can resume the execution using the execute() function or
  /// the step() depending on what you want. You can also inspect the execution of
  /// the program using any of the debugger API (e.g. print_registers(), etc.).
  [[nodiscard]] bool at_breakpoint() const { return m_d.at_breakpoint; }
  /// Returns the total count of registered breakpoints (active or not).
  [[nodiscard]] size_t get_breakpoint_count() const { return m_d.breakpoints.size(); }

  // ------------------------
  // The registers API

  /// Returns the total count of registers available (and registered in the bytecode).
  [[nodiscard]] size_t get_register_count() const { return m_d.bytecode.registers.size(); }
  /// Returns true if the given register index is valid and refers to a real register
  /// in the current Netlist program.
  [[nodiscard]] bool is_valid_register(RegIndex reg) const { return reg < get_register_count(); }
  /// Returns the value of the given requested \a reg. If \a reg does
  /// not exists, the behavior is undefined.
  ///
  /// The bits of the register are stored in the lowest bit of the returned value.
  [[nodiscard]] RegValue get_register(RegIndex reg) const;
  /// Sets the value of the given requested \a reg to \a value. If \a reg
  /// does not exists, the behavior is undefined.
  ///
  /// Only the lowest bits of \a value that can be stored in \a reg are considered.
  /// Others are discarded.
  void set_register(RegIndex reg, RegValue value);
  /// Prints the registers in the given span or all registers to the standard output.
  ///
  /// Both registers_start and registers_end are inclusives.
  ///
  /// Example, `print_registers(2, 4)` will print the 3rd, 4th and 5th
  /// registers (indices are 0-based).
  void print_registers(std::size_t registers_start = 0, std::size_t registers_end = SIZE_MAX);

  // ------------------------
  // The RAM API

  /// Prints a RAM region or all the program's RAM to the standard output.
  ///
  /// Both region_start and region_end are inclusive.
  void print_ram(std::size_t region_start = 0, std::size_t region_end = SIZE_MAX);

  // ------------------------------------------------------
  // The Simulator API
  // ------------------------------------------------------

  /// Returns true if the simulator has reached the end of the bytecode.
  [[nodiscard]] bool at_end() const { return m_d.at_end(); }
  /// Executes all instructions until a breakpoint is found.
  /// If there is no breakpoint, then totally simulate the Netlist.
  ///
  /// You can call this function even if the simulator is actually stopped at
  /// a breakpoint. In that case, the execution is just resumed.
  void execute();
  /// Executes a single step of the simulation.
  ///
  /// You can call this function even if the simulator is actually stopped at
  /// a breakpoint. In that case, the execution is just resumed.
  void step();

private:
  /// Finds the breakpoint that is located at the given position in the bytecode.
  /// If there is no breakpoint at the location, then nullptr is returned.
  std::vector<BreakPoint>::iterator find_breakpoint(std::size_t pc);
  void handle_breakpoint();

  struct Detail : public ByteCodeReader<Detail> {
    explicit Detail(const ByteCode &bytecode);

    ByteCode bytecode;
    std::vector<BreakPoint> breakpoints;
    std::unique_ptr<RegValue[]> registers_value;
    std::unique_ptr<RegValue[]> previous_registers_value;
    bool at_breakpoint = false;

    void handle_nop() {}
    void handle_break();
    void handle_const(const ConstInstruction &inst);
    void handle_not(const NotInstruction &inst);
    void handle_binary_inst(const char *name, const BinaryInstruction &inst);
    void handle_and(const BinaryInstruction &inst);
    void handle_or(const BinaryInstruction &inst);
    void handle_nand(const BinaryInstruction &inst);
    void handle_nor(const BinaryInstruction &inst);
    void handle_xor(const BinaryInstruction &inst);
    void handle_reg(const RegInstruction &inst);
    void handle_slice(const SliceInstruction &inst);
    void handle_select(const SelectInstruction &inst);
  } m_d;
};

#endif
